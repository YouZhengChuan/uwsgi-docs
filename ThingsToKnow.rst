Things to know (best practices and "issues") READ IT !!!
========================================================

*  ``http`` 和 ``http-socket`` 选项是完全不同的options are entirely different beasts.
  The first one spawns an additional process forwarding requests to a series of workers (think about it as a form of shield, at the same level of apache or nginx), while the second one sets workers to natively speak the http protocol.
  TL/DR: if you plan to expose uWSGI directly to the public, use ``--http``, if you want to proxy it behind a webserver speaking http with backends, use ``--http-socket``.
  .. seealso:: :doc:`HTTP`

* Til uWSGI 2.1, by default, sending the ``SIGTERM`` signal to uWSGI means "brutally reload the stack" while the convention is to shut an application down on ``SIGTERM``. To shutdown uWSGI use ``SIGINT`` or ``SIGQUIT`` instead.
  If you absolutely can not live with uWSGI being so disrespectful towards ``SIGTERM``, by all means enable the ``die-on-term`` option. Fortunately, this bad choice has been fixed in uWSGI 2.1

* 如果你计划托管多个应用，那么就当做是帮你自己一个忙，看看 :doc:`Emperor` 文档。

* 始终使用uwsgitop，通过 :doc:`StatsServer` 或一些类似的东东来监控你的应用健康度。

* uWSGI can include features in the core or as loadable plugins. uWSGI packages supplied with OS distributions tend to be modular. In such setups, be sure to load the plugins you require with the ``plugins`` option. A good symptom to recognize an unloaded plugin is messages like "Unavailable modifier requested" in your logs. If you are using distribution supplied packages, double check that you have installed the plugin for your language of choice.

* Config files support a limited form of inheritance, variables, if constructs and simple cycles. Check the :doc:`ConfigLogic` and :doc:`ParsingOrder` pages.

* To route requests to a specific plugin, the webserver needs to pass a magic number known as a modifier to the uWSGI instances. By default this number is set to 0, which is mapped to Python. As an example, routing a request to a :doc:`PSGI` app requires you to set the modifier to ``5`` - or optionally to load the PSGI plugin as modifier ``0``. (This will mean that all modifierless requests will be considered Perl.)

* There is no magic rule for setting the number of processes or threads to use. It is very much application and system dependent. Simple math like ``processes = 2 * cpucores`` will not be enough. You need to experiment with various setups and be prepared to constantly monitor your apps. ``uwsgitop`` could be a great tool to find the best values.

* If an HTTP request has a body (like a POST request generated by a form), you *have* to read (consume) it in your application. If you do not do this, the communication socket with your webserver may be clobbered. If you are lazy you can use the ``post-buffering`` option that will automatically read data for you. For :doc:`Rack` applications this is automatically enabled.

* Always check the memory usage of your apps. The ``memory-report`` option could be your best friend.

* If you plan to use UNIX sockets (as opposed to TCP), remember they are standard filesystem objects. This means they have permissions and as such your webserver must have write access to them.

* Common sense: do not run uWSGI instances as root. You can start your uWSGIs as root, but be sure to drop privileges with the ``uid`` and ``gid`` options.

* uWSGI tries to (ab)use the Copy On Write semantics of the `fork() <http://en.wikipedia.org/wiki/Fork_%28operating_system%29>`_ call whenever possible. By default it will fork after having loaded your applications to share as much of their memory as possible. If this behavior is undesirable for some reason, use the ``lazy-apps`` option. This will instruct uWSGI to load the applications after each worker's ``fork()``. Beware as there is an older options named ``lazy`` that is way more invasive and highly discouraged (it is still here only for backward compatibility)

* By default the Python plugin does not initialize the GIL. This means your app-generated threads will not run. If you need threads, remember to enable them with ``enable-threads``. Running uWSGI in multithreading mode (with the ``threads`` options) will automatically enable threading support. This "strange" default behaviour is for performance reasons, no shame in that.

* If you spawn a new process during a request it will inherit the file descriptors of the worker spawning it - including the socket connected with the webserver/router. If you do not want this behaviour set the ``close-on-exec`` option.

* The Ruby garbage collector is configured by default to run after every request. This is an aggressive policy that may slow down your apps a bit -- but CPU resources are cheaper than memory, and especially cheaper than running out of memory. To tune this frequency use the ``ruby-gc <freq>`` option.

* On OpenBSD, NetBSD and FreeBSD < 9, SysV IPC semaphores are used as the locking subsystem. These operating systems tend to limit the number of allocable semaphores to fairly small values. You should raise the default limits if you plan to run more than one uWSGI instance. FreeBSD 9 has POSIX semaphores, so you do not need to bother with that.

* Do not build plugins using a different config file than used to build the uWSGI binary itself -- unless you like pain or know *exactly* what you are doing.

* By default uWSGI allocates a very small buffer (4096 bytes) for the headers of each request. If you start receiving "invalid request block size" in your logs, it could mean you need a bigger buffer. Increase it (up to 65535) with the ``buffer-size`` option. 

  .. note::

     If you receive '21573' as the request block size in your logs, it could mean you are using the HTTP protocol to speak with an instance speaking the uwsgi protocol. Don't do this.

* If your (Linux) server seems to have lots of idle workers, but performance is still sub-par, you may want to look at the value of the ``ip_conntrack_max`` system variable (``/proc/sys/net/ipv4/ip_conntrack_max``) and increase it to see if it helps.

* Some Linux distributions (read: Debian 4 Etch, RHEL / CentOS 5) make a mix of newer kernels with very old userspace. This kind of combination can make the uWSGI build system spit out errors (most notably on ``unshare()``, pthread locking, ``inotify``...). You can force uWSGI to configure itself for an older system prefixing the 'make' (or whatever way you use to build it) with ``CFLAGS="-DOBSOLETE_LINUX_KERNEL"``

* 默认情况下，在uWSGI启动的适合，stdin被重新映射到 ``/dev/null`` 。如果你需要一个有效的stdin (用于调试、管道等等)，那么添加 ``--honour-stdin`` 。

* 你可以轻松地添加不存在的选项到你的配置文件中 (例如占位符、自定义选项或者应用相关的配置项)。这是一个非常方便的特性，但一旦有错别字，那就头疼了。strict模式 (``--strict``) 将禁用此特性，并且只允许有效的uWSGI选项。

* 一些插件 (最明显的是Python和Perl) 具有代码自动重载机制。虽然这也许听起来很诱人，但是你必须只在开发阶段使用它们，因为它们真的很重。例如，Python的--py-autoreload选项将会在每个检查周期中扫描你整个模块树。

* ``wsgi.file_wrapper`` 是WSGI标准的一个优化。在个别情况下，它会引发错误。例如，当在Python 3.5中返回一个内存中字节缓存 (`io.Bytesio <https://docs.python.org/3/library/io.html#io.BytesIO>`_) 的时候。看看这个 `issue <https://github.com/unbit/uwsgi/issues/1126>`_ 。你可以通过设置选项 ``wsgi-disable-file-wrapper`` 为 ``true`` 来禁用它。
